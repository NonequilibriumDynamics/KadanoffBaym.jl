var documenterSearchIndex = {"docs":
[{"location":"examples/OpenBoseDimer/#OpenBose","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"","category":"section"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"A nice example to illustrate how one can use KadanoffBaym.jl to study open systems is the Bose dimer depicted below.","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"hint: Hint\nA Jupyter notebook for this example is available in our examples folder.","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"(Image: Set-up of the open Bose dimer)","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"It consists of two bosonics modes omega_12 (you can imagine two single-mode cavities at different frequencies), which are coupled with strength J. Additionally, each mode is coupled to its own reservoir at inverse temperature beta_12, respectively. Such a system is described by the master equation","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n\tpartial_t hatrho=-ilefthatH hatrho-hatrho hatH^\n\t\tdaggerright\n\t+ lambdasum_i=1^L left(N_i + 1)hata^phantomdagger_i hatrho  hata^dagger_i + N_i hata^dagger_ihatrho   hata^phantomdagger_i right\nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"for hata^phantomdagger_i hata^dagger_i=1, i=1  L and L=2. The N_i=1(e^beta_i omega_i-1) denote the thermal occupations of the reservoirs. The in this case non-Hermitian Hamiltonian is given by","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n    hatH=sum_i=1^L (omega_i-i lambda (N_i + 12)) hata^dagger_i hata^phantomdagger_i\nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"The bosonic lesser and greater Green functions are ","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n\tleftboldsymbolG^(t t)right_ij = G^_ij(t t) = -ileftlanglehata_j^dagger(t)hata_i^phantomdagger(t)rightrangle \n\tleftboldsymbolG^(t t)right_ij = G^_ij(t t) = -ileftlanglehata_i^phantomdagger(t)hata_j^dagger(t)rightrangle\nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"For convenience, we also introduce the (anti-) time-ordered Green functions","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n\tG^T_ij(t t) = Theta(t - t) G^_ij(t t) +  Theta(t - t) G^_ij(t t) \n\tG^tildeT_ij(t t) = Theta(t - t) G^_ij(t t) +  Theta(t - t) G^_ij(t t)\nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"With the help of these, we can express the \"vertical\" equations of motion compactly:","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n\tpartial_t boldsymbolG^(t t) = -i boldsymbolH boldsymbolG^(t t) + lambda operatornamediag (N_1  N_L) boldsymbolG^tildeT(t t)  \n\tpartial_t boldsymbolG^(t t) = -i boldsymbolH^dagger boldsymbolG^(t t) - lambda operatornamediag (N_1 + 1  N_L + 1) boldsymbolG^T(t t) \nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"where boldsymbolH = operatornamediag(omega_1- ilambda (N_1 + 12)  omega_L- ilambda(N_L + 12)). As in our previous example, we also need the equations in the \"diaognal\" time direction, which in the present case become","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"beginalign*\n\tpartial_T G_ij^(T 0)_W = \n\t-i leftboldsymbolH boldsymbolG^(T 0)_W - boldsymbolG^(T 0)_W boldsymbolH^daggerright_ij \n\t+ fracilambda2 (N_i + N_j) (G_ij^(T 0)_W + G_ij^(T 0)_W) \n\tpartial_T G_ij^(T 0)_W = -i leftboldsymbolH^dagger boldsymbolG^(T 0)_W - boldsymbolG^(T 0)_W boldsymbolHright_ij \n\t\n\t- fracilambda2 (N_i + N_j + 2) (G_ij^(T 0)_W + G_ij^(T 0)_W)\nendalign*","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"where the subscript W again indicates Wigner coordinates. ","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"Translating all of this into code is now straightforward! We start by defining the Green functions and their initial conditions:","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"using KadanoffBaym, LinearAlgebra\n\n# Lattice size\nL = 2\n\n# Allocate the initial Green functions (time arguments at the end)\nGL = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\nGG = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\n\n# Initial condition\nGL[1, 1] = -im * diagm([0.0, 2])\nGG[1, 1] = -im * I(2) + GL[1,1]","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"Then we assign all of the parameters we need:","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"# Non-Hermitian Hamiltonian\nω₁ = 2.5\nω₂ = 0.0\nJ = pi / 4\n\nγ = 1\n\nN₁ = 1.\nN₂ = 0.1\n\nH = [ω₁ - 0.5im * ((N₁ + 1) + N₁ * γ) J; J ω₂ - 0.5im * ((N₂ + 1) + N₂ * γ)]","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"As the last step, we write down the equations of motion:","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"# Right-hand side for the \"vertical\" evolution\nfunction fv!(out, _, _, _, t, t′)\n    out[1] = -1.0im * (H * GL[t, t′] + [[1.0im * N₁ * γ, 0] [0, 1.0im * N₂ * γ]] * GL[t, t′])\n    out[2] = -1.0im * (adjoint(H) * GG[t, t′] - 1.0im * [[(N₁ + 1), 0] [0, (N₂ + 1)]] * GG[t, t′])\nend","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"Observe how we have converted the (anti-) time-ordered Green functions G^T G^tildeT into lesser and greater functions by explicitly using the fact that we are operating on the tt triangle of the two-time grid (t t). By combining fv! with its adjoint as before, we also obtain the \"diagonal\" equations as","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"# Right-hand side for the \"diagonal\" evolution\nfunction fd!(out, _, _, _, t, t′)\n    out[1] = (-1.0im * (H * GL[t, t] - GL[t, t] * adjoint(H)\n             + 1.0im * γ * [[N₁ * (GL[1, 1, t, t] + GG[1, 1, t, t]), (N₁ + N₂) * (GL[2, 1, t, t] + GG[2, 1, t, t]) / 2] [(N₁ + N₂) * (GL[1, 2, t, t] + GG[1, 2, t, t]) / 2, N₂ * (GL[2, 2, t, t] + GG[2, 2, t, t])]])\n             )\n    out[2] = (-1.0im * (adjoint(H) * GG[t, t] - GG[t, t] * H\n             - 1.0im * [[(N₁ + 1) * (GL[1, 1, t, t] + GG[1, 1, t, t]), (N₁ + N₂ + 2) * (GG[2, 1, t, t] + GL[2, 1, t, t]) / 2] [(N₁ + N₂ + 2) * (GG[1, 2, t, t] + GL[1, 2, t, t]) / 2, (N₂ + 1) * (GL[2, 2, t, t] + GG[2, 2, t, t])]])\n             )\nend","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"Calling the solver is again a one-liner:","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"sol = kbsolve!(fv!, fd!, [GL, GG], (0.0, 32.0); atol=1e-6, rtol=1e-4)","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"tip: Tip\nBy importing Julia's FFTW and Interpolations packages, we can also obtain the Wigner-transformed Green functions.","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"using FFTW, Interpolations\nfunction wigner_transform_itp(x::AbstractMatrix, ts::Vector; fourier = true, ts_lin = range(first(ts), last(ts); length = length(ts)))\n    itp = interpolate((ts, ts), x, Gridded(Linear()))\n    return wigner_transform([itp(t1, t2) for t1 in ts_lin, t2 in ts_lin]; ts = ts_lin, fourier = fourier)\nend\n\nρ_11_wigner, (taus, ts) = wigner_transform_itp((GG.data - GL.data)[1, 1, :, :], sol.t; fourier=false)\nρ_11_FFT, (ωs, ts) = wigner_transform_itp((GG.data - GL.data)[1, 1, :, :], sol.t; fourier=true)","category":"page"},{"location":"examples/OpenBoseDimer/","page":"Open Bose Dimer","title":"Open Bose Dimer","text":"If you want to see plots of all the results, you can find those in our corresponding Jupyter notebook.","category":"page"},{"location":"examples/StochasticProcesses/#StochasticProcesses","page":"Stochastic Processes","title":"Stochastic Processes","text":"","category":"section"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"KadanoffBaym.jl can also be used to simulate stochastic processes. Below, we will give the simplest example to illustrate how to do this. In cases where other methods are too expensive or inapplicable, this approach can be an economic and insightful alternative. ","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"tip: Tip\nMore background on the connection between KadanoffBaym.jl and stochastic processes can be found in section 4.2 of our paper and also here.","category":"page"},{"location":"examples/StochasticProcesses/#OUProcess","page":"Stochastic Processes","title":"Ornstein-Uhlenbeck Process","text":"","category":"section"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"The Ornstein-Uhlenbeck (OU) process\\cite{VanKampen2007, gardiner1985handbook} is defined by the stochastic differential equation (SDE)","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    mathrmd x(t) = -theta x(t)mathrmd t + sqrtDmathrmd W(t)\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where W(t), t 0 is a one-dimensional Brownian motion and theta  0. The Onsager-Machlup path integral","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    intmathcalDxexpleft-frac12Dintmathrmdt left(partial_tx(t) +theta x(t)right)^2right\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"is a possible starting point to derive the corresponding MSR action via a Hubbard-Stratonovich transformation. The classical MSR action","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    Sx hatx =   intmathrmdtleft  mathrmihatx(t)(partial_tx(t) + theta x(t)) + D hatx^2(t)2 right\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"is then equivalent to it. Note also that we are employing It\\^o regularisation for simplicity. It is also common to define a purely imaginary response field tildehatx = mathrmihatx, which is then integrated along the imaginary axis. The retarded Green function G^R and the statistical propagator F are then commonly defined as","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    G^R(t t) = langlex(t)hatx(t)rangle \n\tF(t t) = langlex(t)x(t)rangle - langlex(t)rangle langlex(t)rangle\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"The equations of motion of the response Green functions are","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n\tdelta(t - t) = -mathrmipartial_t G^A(t t) + mathrmitheta G^A(t t)     \n\tdelta(t - t) = phantom-mathrmipartial_t G^R(t t) + mathrmitheta G^R(t t)\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"admitting the solutions","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n\tG^A(t t) = G^A(t - t) = -mathrmiTheta(t - t)mathrme^-theta(t - t) \n\tG^R(t t) = G^R(t - t) = -mathrmiTheta(t - t)mathrme^-theta(t - t)\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"The equations of motion of the statistical propagator in \"vertical\" time t and \"horizontal\" time t read","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    partial_t F(t t)     =  -theta F(t t) + mathrmi DG^A(t t)  \n    partial_t F(t t)  =  -theta F(t t) + mathrmi DG^R(t t)   \nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"respectively, while in Wigner coordinates T = (t+t)2, tau = t - t, we find","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    partial_T F(T tau)_W     =  -2theta F(T tau)_W + mathrmi Dleft( G^A(T tau)_W + G^R(T tau)_W right)  \n    partial_tau F(T tau)_W  =  fracmathrmi D2 left( G^A(T tau)_W - G^R(T tau)_W right) \nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"To cover the two-time mesh completely, one could in principle use any two of the four equations for F. Our convention is to pick the equation in \"vertical\" time t with tt and the equation in \"diagonal\" time T with tau=0, such that together with the symmetries relations of the classical Green functiosn, the problem is fully determined by the initial conditions and these two equations:","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    partial_t F(t t)     =  -theta F(t t) + mathrmi DG^A(t t) \n    partial_T F(T 0)_W  =  -2theta F(T 0)_W + D    \nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where we have used the response identity G^A(T 0)_W + G^R(T 0)_W = -mathrmi, and G^A(t t) = 0 when t  t. For comparison, the analytical solution for the variance or statistical propagator reads","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginalign*\n    mathcalF(t t) = mathcalF(0 0)mathrme^-theta(t + t) - fracD2theta left( mathrme^-theta(t + t) - mathrme^-theta t - t right)\n\t= left( mathcalF(0 0) - fracD2theta right)mathrme^-theta(t + t) + fracmathrmi D2thetaleft( G^A(t t) + G^R(t t) right)\nendalign*","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"To apply KadanoffBaym.jl, we begin by defining parameters and initial conditions:","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"# Final time\ntmax = 4.0\n\n# Drift\nθ = 1.\n\n# Diffusion strength (in units of θ)\nD = 8.0\n\n# Initial condition\nN₀ = 1.0\nF = GreenFunction(N₀ * ones(1, 1), Symmetrical)","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"note: Note\nObserve how we have used the symmetry Symmetrical to define the classical type of GreenFunction. ","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Now the equation in \"vertical\" time t is simply    ","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"# Right-hand side for the \"vertical\" evolution\nfunction fv!(out, _, _, _, t1, t2)\n    out[1] = -θ * F[t1, t2]\nend","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"warning: Warning\nIn this numerical version of the analytical equation above, we have made explicit use of the fact that G^A(t t) = 0 when t  t. However, since KadanoffBaym.jl uses a so-called multi-step predictor-corrector method to solve equations (i.e. a method using not a single point but multiple points from the past to predict the next point), it can happen that points with t  t are actually accessed, in which case the G^A(t t) term in the above equation does contribute. One way to prevent this would be to restrict the solver to using a one-step method early on, i.e. until enough points with t  t are known. ","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"In \"diagonal\" time T we have","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"# Right-hand side for the \"diagonal\" evolution\nfunction fd!(out, _, _, _, t1, t2)\n    out[1] = -θ * 2F[t1, t2] + D\nend","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"To learn about the signatures (out, _, _, _, t1, t2) of fv! and fd!, consult the documentation of kbsolve!. All we need to do now is","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"# Call the solver\nsol = kbsolve!(fv!, fd!, [F], (0.0, tmax); atol=1e-8, rtol=1e-6)","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"The numerical results obtained with KadanoffBaym.jl are shown in our paper and are in agreement with the analytical solutions.","category":"page"},{"location":"examples/StochasticProcesses/","page":"Stochastic Processes","title":"Stochastic Processes","text":"hint: Hint\nA Jupyter notebook for this example is available in our examples folder.","category":"page"},{"location":"examples/FermiHubbard2B/#FHM_I","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"","category":"section"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"note: Note\nA Jupyter notebook related to this example is available in our examples folder.","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"To see KadanoffBaym.jl in full strength, we need to consider an interacting system such as the Fermi-Hubbard model","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"beginalign*\n\thatH = - J sum_langleijranglesum_sigma hatc^dagger_isigma hatc^phantomdagger_i+1sigma + Usum_i=1^L  hatc^dagger_iuparrow hatc^phantomdagger_iuparrow   hatc^dagger_idownarrow hatc^phantomdagger_idownarrow \nendalign*","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"where the hatc_isigma^dagger hatc_isigma^phantomdagger, sigma=uparrow downarrow are now spin-dependent fermionic creation and annihilation operators. The model describes electrons on a lattice that can hop to neighbouring sites via the coupling J while also feeling an on-site interaction U. The spin-diagonal Green functions are defined by","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"beginalign*\n\tleftboldsymbolG_sigma^(t t)right_ij = G^_ij sigma(t t) = phantom- mathrmileftlanglehatc_j sigma^dagger(t)hatc_i sigma^phantomdagger(t)rightrangle \n\tleftboldsymbolG_sigma^(t t)right_ij = G^_ij sigma(t t) = -mathrmileftlanglehatc_i sigma^phantomdagger(t)hatc_j sigma^dagger(t)rightrangle\nendalign*","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"The equations of motion for these Green functions in \"vertical\" time t can be written compactly as","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"beginalign*\n        (mathrmipartial_t - boldsymbolh) boldsymbolG_sigma^lessgtr(t t) = int_t_0^tmathrmds  leftboldsymbolSigma_sigma^(t s) - boldsymbolSigma_sigma^(t s) right boldsymbolG_sigma^lessgtr(s t) + int_t_0^tmathrmds  boldsymbolSigma_sigma^lessgtr(t s) leftboldsymbolG_sigma^(s t) - boldsymbolG_sigma^(s t) right\nendalign*","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"where boldsymbolh describes the single-particle contributions (i.e. the hopping), and the matrices boldsymbolG^lessgtr are assumed to be block-diagonal in the spin degree-of-freedom. The Hartree-Fock part of the self-energy now is","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"beginalign*\n    Sigma^mathrmHF_uparrowij(t t) = mathrmidelta_ijdelta(t - t) G^_downarrowii(t t)\n    Sigma^mathrmHF_downarrowij(t t) = mathrmidelta_ijdelta(t - t) G^_uparrowii(t t)\nendalign*    ","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"In the so-called second Born approximation, the contribution to next order in U is also taken into account:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"beginalign*\n    Sigma^lessgtr_ij uparrow  (t t) = U^2 G^lessgtr_ij uparrow(t t) G^lessgtr_ij downarrow(t t) G^gtrless_ji downarrow(t t)\n    Sigma^lessgtr_ij downarrow(t t) = U^2 G^lessgtr_ij downarrow(t t) G^lessgtr_ij uparrow(t t) G^gtrless_ji uparrow(t t)\nendalign*","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Now that we have the equations set up, we import KadanoffBaym.jl alongside some auxiliary packages:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"using KadanoffBaym, LinearAlgebra, BlockArrays","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Then, we use KadanoffBaym's built-in data structure GreenFunction to define our lesser and greater Green functions","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Lattice size\nL = 8\n\n# Allocate the initial Green functions (time arguments at the end)\nGL_u = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\nGG_u = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\nGL_d = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\nGG_d = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Observe that we denote boldsymbolG_uparrow^ by GL_u and boldsymbolG_downarrow^ by GL_d, for instance. As a lattice structure, we choose the 8-site 3D qubic lattice shown in Fig. 8 of our paper.","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"As an (arbitrary) Gaussian initial condition, we take a non-equilibrium distribution of the charge over the cube (all electrons at the bottom of the cube):","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Initial conditions\nN_u = zeros(L)\nN_d = zeros(L)\n\nN_u[1:4] = 0.1 .* [1, 1, 1, 1]\nN_d[1:4] = 0.1 .* [1, 1, 1, 1]\n\nN_u[5:8] = 0.0 .* [1, 1, 1, 1]\nN_d[5:8] = 0.0 .* [1, 1, 1, 1]\n\nGL_u[1, 1] = 1.0im * diagm(N_u)\nGG_u[1, 1] = -1.0im * (I - diagm(N_u))\nGL_d[1, 1] = 1.0im * diagm(N_d)\nGG_d[1, 1] = -1.0im * (I - diagm(N_d))","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"note: Note\nAccessing GreenFunction with only two arguments gives the whole matrix at a given time, i.e. GL_u[1, 1] is equivalent to GL_u[:, :, 1, 1].","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"To keep our data ordered, we define an auxiliary struct to hold them:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Base.@kwdef struct FermiHubbardData2B{T}\n    GL_u::T\n    GG_u::T\n    GL_d::T\n    GG_d::T\n\n    ΣL_u::T = zero(GL_u)\n    ΣG_u::T = zero(GG_u)\n    ΣL_d::T = zero(GL_d)\n    ΣG_d::T = zero(GG_d)\nend\n\ndata = FermiHubbardData2B(GL_u=GL_u, GG_u=GG_u, GL_d=GL_d, GG_d=GG_d)","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Furthermore, we also defined an auxiliary struct specifying the parameters of the model:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Base.@kwdef struct FermiHubbardModel{T}\n    # interaction strength\n    U::T\n\n    # 8-site 3D cubic lattice\n    h = begin\n        h = BlockArray{ComplexF64}(undef_blocks, [4, 4], [4, 4])\n        diag_block = [0 -1 0 -1; -1 0 -1 0; 0 -1 0 -1; -1 0 -1 0]\n        setblock!(h, diag_block, 1, 1)\n        setblock!(h, diag_block, 2, 2)\n        setblock!(h, Diagonal(-1 .* ones(4)), 1, 2)\n        setblock!(h, Diagonal(-1 .* ones(4)), 2, 1)\n\n        h |> Array\n    end\n\n    H_u = h\n    H_d = h\nend\n\n# Relatively small interaction parameter\nconst U₀ = 0.25\nmodel = FermiHubbardModel(U = t -> U₀)","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Note how we have defined the interaction parameter U as a (constant) Julia Function - this enables us to study quenches with time-dependent interaction (s. also our paper).","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"The final step before setting up the actual equations is to define a callback function for the self-energies in second Born approximation:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Callback function for the self-energies\nfunction second_Born!(model, data, times, _, _, t, t′)\n    # Unpack data and model\n    (; GL_u, GG_u, GL_d, GG_d, ΣL_u, ΣG_u, ΣL_d, ΣG_d) = data\n    (; U) = model\n        \n    # Resize self-energies when Green functions are resized    \n    if (n = size(GL_u, 3)) > size(ΣL_u, 3)\n        resize!(ΣL_u, n)\n        resize!(ΣG_u, n)\n        resize!(ΣL_d, n)\n        resize!(ΣG_d, n)        \n    end\n    \n    # The interaction varies as a function of the forward time (t+t')/2\n    U_t = U((times[t] + times[t′])/2)\n    \n    # Define the self-energies\n    ΣL_u[t, t′] = U_t^2 .* GL_u[t, t′] .* GL_d[t, t′] .* transpose(GG_d[t′, t])\n    ΣL_d[t, t′] = U_t^2 .* GL_u[t, t′] .* GL_d[t, t′] .* transpose(GG_u[t′, t])\n    \n    ΣG_u[t, t′] = U_t^2 .* GG_u[t, t′] .* GG_d[t, t′] .* transpose(GL_d[t′, t])\n    ΣG_d[t, t′] = U_t^2 .* GG_u[t, t′] .* GG_d[t, t′] .* transpose(GL_u[t′, t])\nend","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"note: Note\nThe omitted arguments _ in the function definition refer to the adaptive integration weights of KadanoffBaym. They are only needed when the self-energy contains actual time integrals (as in the T-matrix approximation).","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"Unlike for the non-interacting tight-binding model, the equations of motion above contain integrals over time. This makes them so-called Volterra integro-differential equations (VIDEs). Now the integrals are always either of the first form int_t_0^tmathrmds  leftboldsymbolSigma_sigma^(t s) - boldsymbolSigma_sigma^(t s) right boldsymbolG_sigma^lessgtr(s t) or of the second form int_t_0^tmathrmds  boldsymbolSigma_sigma^lessgtr(t s) leftboldsymbolG_sigma^(s t) - boldsymbolG_sigma^(s t) right The discretization of these time convolutions results in a sum of matrix-products over all time indices. To be as efficient as possible, this suggests to introduce two auxiliary functions that handle these integrations by avoiding unnecessary allocations:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Auxiliary integrator for the first type of integral\nfunction integrate1(hs::Vector, t1, t2, A::GreenFunction, B::GreenFunction, C::GreenFunction; tmax=t1)\n    retval = zero(A[t1, t1])\n\n    @inbounds for k in 1:tmax\n        @views LinearAlgebra.mul!(retval, A[t1, k] - B[t1, k], C[k, t2], hs[k], 1.0)\n    end\n    return retval\nend\n\n# Auxiliary integrator for the second type of integral\nfunction integrate2(hs::Vector, t1, t2, A::GreenFunction, B::GreenFunction, C::GreenFunction; tmax=t2)\n    retval = zero(A[t1, t1])\n\n    @inbounds for k in 1:tmax\n        @views LinearAlgebra.mul!(retval, A[t1, k], B[k, t2] - C[k, t2], hs[k], 1.0)\n    end\n    return retval\nend","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"note: Note\nThe first argument hs::Vector denotes the adaptive integration weights provided by KadanoffBaym. Since these depend on the boundary points of the integration, there will usually be different weight vectors for the two integrals.","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"We are finally ready to define the equations of motion! In \"vertical\" time, we have","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Right-hand side for the \"vertical\" evolution\nfunction fv!(model, data, out, times, h1, h2, t, t′)\n    # Unpack data and model\n    (; GL_u, GG_u, GL_u, GG_d, ΣL_u, ΣG_u, ΣL_d, ΣG_d) = data\n    (; H_u, H_d, U) = model\n\n    # Real-time collision integrals\n    ∫dt1(A, B, C) = integrate1(h1, t, t′, A, B, C)\n    ∫dt2(A, B, C) = integrate2(h2, t, t′, A, B, C)\n    \n    # The interaction varies as a function of the forward time (t+t')/2\n    U_t = U((times[t] + times[t′])/2)\n    \n    # Hartree-Fock self-energies\n    ΣHF_u(t, t′) = im * U_t * Diagonal(GL_d[t, t])\n    ΣHF_d(t, t′) = im * U_t * Diagonal(GL_u[t, t])\n    \n    # Equations of motion\n    out[1] = -1.0im * ((H_u + ΣHF_u(t, t′)) * GL_u[t, t′] + \n            ∫dt1(ΣG_u, ΣL_u, GL_u) + ∫dt2(ΣL_u, GL_u, GG_u)\n        )\n\n    out[2] = -1.0im * ((H_u + ΣHF_u(t, t′)) * GG_u[t, t′] + \n            ∫dt1(ΣG_u, ΣL_u, GG_u) + ∫dt2(ΣG_u, GL_u, GG_u)\n        )\n\n    out[3] = -1.0im * ((H_d + ΣHF_d(t, t′)) * GL_d[t, t′] + \n            ∫dt1(ΣG_d, ΣL_d, GL_d) + ∫dt2(ΣL_d, GL_d, GG_d)\n        )\n\n    out[4] = -1.0im * ((H_d + ΣHF_d(t, t′)) * GG_d[t, t′] +\n            ∫dt1(ΣG_d, ΣL_d, GG_d) + ∫dt2(ΣG_d, GL_d, GG_d)\n        )  \n    \n    return out\nend","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"As for the tight-binding model, the equation of motion in \"diagonal\" time T follows by subtracting its own adjoint from the vertical equation:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# Right-hand side for the \"diagonal\" evolution\nfunction fd!(model, data, out, times, h1, h2, t, t′)\n    fv!(model, data, out, times, h1, h2, t, t)\n    out .-= adjoint.(out)\nend","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"After defining a final time and some tolerances, we give everything to kbsolve!:","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"# final time\ntmax = 4\n\n# tolerances\natol = 1e-8\nrtol = 1e-6\n\n# Call the solver\nsol = kbsolve!(\n    (x...) -> fv!(model, data, x...),\n    (x...) -> fd!(model, data, x...),\n    [data.GL_u, data.GG_u, data.GL_d, data.GG_d],\n    (0.0, tmax);\n    callback = (x...) -> second_Born!(model, data, x...),\n    atol = atol,\n    rtol = rtol,\n    stop = x -> (println(\"t: $(x[end])\"); flush(stdout); false)\n)","category":"page"},{"location":"examples/FermiHubbard2B/","page":"Fermi-Hubbard Model I","title":"Fermi-Hubbard Model I","text":"That's it! Results for tmax=32 are shown in our paper. Note that this implementation via KadanoffBaym is about as compact as possible.","category":"page"},{"location":"examples/TightBindingModel/#TightBinding","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"","category":"section"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"To get a feeling for how to use KadanoffBaym.jl, we begin by solving a simple example, the so-called tight-binding model:","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"\nbeginalign*\n\thatH = sum_i=1^L varepsilon_i hatc_i^dagger hatc_i^phantomdagger + J sum_langle i jrangleleft(hatc_i^dagger hatc_j^phantomdagger + hatc_j^dagger hatc_i^phantomdaggerright)\nendalign*\n","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"where the hatc_i^dagger hatc_i^phantomdagger are fermionic creation and annihilation operators. The model describes a bunch of electrons on a lattice that can hop to neighbouring sites via the coupling J. The usual quantities of interest can be obtained from the so-called lesser and greater Green functions defined by","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"beginalign*\n\tleftboldsymbolG^(t t)right_ij = G^_ij(t t) = phantom- ileftlanglehatc_j^dagger(t)hatc_i^phantomdagger(t)rightrangle \n\tleftboldsymbolG^(t t)right_ij = G^_ij(t t) = -ileftlanglehatc_i^phantomdagger(t)hatc_j^dagger(t)rightrangle\nendalign*","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"The equations of motion for these Green functions in \"vertical\" and \"diagonal\" time have a simple form and can be written compactly as","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"beginalign*\n\tpartial_t boldsymbolG^lessgtr(t t) = -iboldsymbolH boldsymbolG^lessgtr(t t) \n\tpartial_T boldsymbolG^lessgtr(T 0)_W = -iboldsymbolHboldsymbolG^lessgtr(T 0)_W\nendalign*","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"where the square brackets denote the commutator, and the Hamiltonian matrix is given by","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"beginalign*\n\tboldsymbolH = \n\tbeginpmatrix\n\t\tvarepsilon_1  J                 \n\t\tJ              ddots  ddots    \n\t\t               ddots  ddots  J \n\t\t                       J  varepsilon_L \n\tendpmatrix\nendalign*","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"Remember also that in Wigner coordinates, the \"forward\" time is defined by T = fract+t2 and partial_T = partial_t + partial_t.","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"First, we import KadanoffBaym.jl alongside Julia's linear-algebra package:","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"using KadanoffBaym, LinearAlgebra","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"Then, we use the built-in data structure GreenFunction to define our lesser and greater Green functions","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Lattice size\nL = 10\n\n# Allocate the initial lesser and greater Green functions (time arguments at the end)\nGL = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)\nGG = GreenFunction(zeros(ComplexF64, L, L, 1, 1), SkewHermitian)","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"As our initial condition, we put a single electron on lattice site one:","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Initial occupation\nN_0 = 1.0\nGL[1, 1] = zeros(ComplexF64, L, L)\nGL[1, 1, 1, 1] = 1.0im\n\n# Greater function follows from lesser by anti-commutation\nGG[1, 1] = -im * I(L) + GL[1, 1]","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"Note how accessing GreenFunction with only two arguments gives the whole matrix at a given time, i.e. GL[1, 1] is equivalent to GL[:, :, 1, 1].","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"For illustration, we use a Hamiltonian matrix boldsymbolH with unit hopping J=1 defined as","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Spacing of energy levels\nε = 5e-2\n\n# Hamiltonian with on-site energies and nearest-neighbour hopping\nH = SymTridiagonal([ε * (i-1) for i in 1:L], -ones(L))","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"We define the equation of motion in the \"vertical\" time t as","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Right-hand side for the \"vertical\" evolution\nfunction fv!(out, times, h1, h2, t1, t2)\n    out[1] = -im * H * GL[t1, t2]\n    out[2] = -im * H * GG[t1, t2]\nend","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"Finally, the the equation of motion in the \"diagonal\" time T follows by subtracting its own adjoint from the vertical equation:","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Right-hand side for the \"diagonal\" evolution\nfunction fd!(out, times, h1, h2, t1, t2)\n  fv!(out, times, h1, h2, t1, t2)\n  out[1] -= adjoint(out[1])\n  out[2] -= adjoint(out[2])\nend","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"Note that the unused arguments times, h1, h2 are indeed only necessary when solving interacting systems (i.e. systems with integrals in their equations of motion). All that remains to be done is give our definitions to kbsolve!:","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"# Call the solver\n@time sol = kbsolve!(fv!, fd!, [GL, GG], (0.0, 20.0); atol=1e-8, rtol=1e-6)","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"When we plot(sol.t, mapreduce(permutedims, vcat, [imag(diag(GL[t, t])) for t in eachindex(sol.t)])), we obtain","category":"page"},{"location":"examples/TightBindingModel/","page":"Tight-Binding Model","title":"Tight-Binding Model","text":"(Image: Time-dependent occupations numbers of a ten-site tight-binding model)","category":"page"},{"location":"examples/BoseEinsteinCondensate/#BEC","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"","category":"section"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"In this example we will use KadanoffBaym.jl to study dephasing in Bose-Einstein condensates (see Chp. 3 here). To do this, we will need to solve one-time differential equations for the condensate amplitude varphi(t) and the so-called equal-time Keldysh Green function G^K(t t).","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"hint: Hint\nA Jupyter notebook for this example is available in our examples folder.","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"The Lindblad master equation describing this systems reads","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"beginalign\n    beginsplit\n    \tdothatrho = -iomega_0a^dagger a hatrho +fraclambda2left 2ahatrho a^dagger - left( a^daggerahatrho + hatrho a^daggera right)right + fracgamma2left 2a^daggerhatrho a - left( aa^daggerhatrho + hatrho aa^dagger right)right \n        + Dleft 2a^daggerahatrho a^daggera - left( a^daggeraa^daggerahatrho + hatrho a^daggeraa^daggera right)right    \n    endsplit\nendalign","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"where lambda  0 is the loss parameter, gamma  0 represents the corresponding gain, and D  0 is the constant that introduces dephasing. The derivation for the equations of motion for varphi(t) and G^K(t t) is again given here and leads to","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"beginalign\n    beginsplit\n    dotvarphi(t) =  -iomega_0varphi(t) -frac12(lambda - gamma + 2 D)varphi(t) \n    dotG^K(t t) = -(lambda - gamma)G^K(t t) - ileft(lambda + gamma + 2 D varphi(t)^2right)\n    endsplit\nendalign","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"To make these expressions more transparent, we set varphi(t) = sqrt2N(t)mathrme^i theta(t) and G^K(t t) = -i(2delta N(t) + 1), where N and delta N are the condensate and non-condensate occupation, respectively. For these quantities, we obtain","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"beginalign\n    beginsplit\n    dotN =  (gamma - lambda -2 D)N \n    delta dotN =  gamma(delta N + 1) - lambdadelta N + 2DN\n    endsplit\nendalign","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"Translating all of this into code is now straightforward! We start by defining the condensate and the Keldysh Green function along with their initial conditions:","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"using KadanoffBaym, LinearAlgebra\n\n# parameters\nω₀ = 1.0\nλ = 0.0\nγ = 0.0\nD = 1.0 \n\n# initial occupations\nN = 1.0\nδN = 0.0\n\n# One-time function for the condensate\nφ = GreenFunction(zeros(ComplexF64, 1), OnePoint)\n\n# Allocate the initial Green functions (time arguments at the end)\nGK = GreenFunction(zeros(ComplexF64, 1, 1), SkewHermitian)\n\n# Initial conditions\nGK[1, 1] = -im * (2δN + 1)\nφ[1] = sqrt(2N)","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"In the next step, we write down the equations of motion:","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"# we leave the vertical equation empty since we can solve for GK in equal-time only\nfunction fv!(out, ts, h1, h2, t, t′)\n    out[1] = zero(out[1])\nend\n\n# diagonal equation for GK\nfunction fd!(out, ts, h1, h2, t, _)\n    out[1] = -(λ - γ) * GK[t, t] - im * (λ + γ + 2D * abs2(φ[t]))\nend\n\n# one-time equation for condensate amplitude\nfunction f1!(out, ts, h1, t)\n    out[1] = -im * ω₀ * φ[t] - (1/2) * (λ - γ + 2D) * φ[t]\nend","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"Calling the solver is again a one-liner:","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"sol = kbsolve!(fv!, fd!, [GK,], (0.0, 1.0); atol=1e-6, rtol=1e-4, v0 = [φ,], f1! =f1!)","category":"page"},{"location":"examples/BoseEinsteinCondensate/","page":"Bose-Einstein Condensate","title":"Bose-Einstein Condensate","text":"If you want a plot of the results, you can find it in our corresponding Jupyter notebook.","category":"page"},{"location":"#Welcome!","page":"Overview","title":"Welcome!","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"KadanoffBaym.jl is the first fully adaptive solver for Kadanoff-Baym equations written in Julia.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"tip: Tip\nTo learn more about the solver and Kadanoff-Baym equations, have a look into our accompanying paper.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To install, use Julia's built-in package manager","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> ] add KadanoffBaym","category":"page"},{"location":"#Scalability","page":"Overview","title":"Scalability","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"For now, KadanoffBaym.jl is restricted to run on a single machine, for which the maximum number of threads available will be used. You can set this number by running Julia with the thread flag","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia -t auto","category":"page"},{"location":"#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To learn how to work with KadanoffBaym.jl, there are two options:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The examples folder of our repository, which contains notebooks for all of the systems studied in our paper.\nThe examples section of this documentation. If you are interested in quantum dynamics, we recommend you start with the tight-binding model. More advanced users can jump directly to Fermi-Hubbard model part I about the second Born approximation. Part II shows how to solve the more involved T-matrix approximation. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nKadanoffBaym.jl can also be used to simulate stochastic processes. An introduction to this topic is given here.","category":"page"},{"location":"#Library","page":"Overview","title":"Library","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"KadanoffBaym.jl was designed to be lean and simple and hence only exports a handful of functions, namely GreenFunction (together with two possible time symmetries, Symmetrical and SkewHermitian) and the integrator kbsolve!. Besides these, wigner_transform can be used to analyze data in a Wigner(-Ville) transformed basis and TimeOrderedGreenFunction to quickly compute the Keldysh components (greater, lesser, retarded and advanced) of time convolutions via the Langreth rules.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nYou need to import an FFT library – e.g., FFTW – to use wigner_transform.","category":"page"},{"location":"#Index","page":"Overview","title":"Index","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"#Solver","page":"Overview","title":"Solver","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"kbsolve!","category":"page"},{"location":"#KadanoffBaym.kbsolve!","page":"Overview","title":"KadanoffBaym.kbsolve!","text":"kbsolve!(fv!::Function, fd!::Function, u0::Vector{<:AbstractGreenFunction}, (t0, tmax)::Tuple{Union{Real, Vector{<:Real}}, Real})\n\nSolves the 2-time Voltera integro-differential equation\n\ndu(t_1t_2)  dt_1 = f_v(t_1t_2) = vut_1t_2 + _t0^t1 dτ K_1^vut_1t_2τ + _t0^t2 dτ K_2^vut_1t_2τ\n\ndu(t_1t_2)  dt_2 = f_h(t_1t_2) = hut_1t_2 + _t0^t1 dτ K_1^hut_1t_2τ + _t0^t2 dτ K_2^hut_1t_2τ\n\nfor 2-point functions u0 from t0 to tmax.\n\nParameters\n\nfv!(out, ts, w1, w2, t1, t2): The right-hand side of du(t_1t_2)dt_1  on the time-grid (ts x ts). The weights w1 and w2 can be used to integrate the Volterra kernels K1v and K2v as sum_i w1_i K1v_i and  sum_i w2_i K2v_i, respectively. The output is saved in-place in out, which has the same shape as u0\nfd!(out, ts, w1, w2, t1, t2): The right-hand side of (du(t_1t_2)dt_1 + du(t_1t_2)dt_2)_t_2  t_1\nu0::Vector{<:GreenFunction}: List of 2-point functions to be integrated\n(t0, tmax): A tuple with the initial time(s) t0 – can be a vector of  past times – and final time tmax\n\nOptional keyword parameters\n\nf1!(out, ts, w1, t1): The right-hand-side of dv(t_1)dt_1. The weight w1 can be used to integrate the Volterra kernel and the output is saved in-place in out,  which has the same shape as v0\nv0::Vector{<:GreenFunction}: List of 1-point functions to be integrated\ncallback(ts, w1, w2, t1, t2): A function that gets called everytime the  2-point function at indices (t1, t2) is updated. Can be used to update functions which are not being integrated, such as self-energies\nstop(ts): A function that gets called at every time-step that stops the  integration when it evaluates to true\natol::Real: Absolute tolerance (components with magnitude lower than  atol do not guarantee number of local correct digits)\nrtol::Real: Relative tolerance (roughly the local number of correct digits)\ndtini::Real: Initial step-size\ndtmax::Real: Maximal step-size\nqmax::Real: Maximum step-size factor when adjusting the time-step\nqmin::Real: Minimum step-size factor when adjusting the time-step\nγ::Real: Safety factor for the calculated time-step such that it is  accepted with a higher probability\nkmax::Integer: Maximum order of the adaptive Adams method\nkmax_vie::Integer: Maximum order of interpolant of the Volterra integrals Heuristically, it seems that having too high of a kmax_vie can result in numerical instabilities\n\nNotes\n\nDue to high memory and computation costs, kbsolve! mutates the initial condition u0  and only works with in-place rhs functions, unlike standard ODE solvers.\nThe Kadanoff-Baym timestepper is a 2-time generalization of the variable Adams method presented in E. Hairer, S. Norsett and G. Wanner, Solving Ordinary Differential Equations I: Non- stiff Problems, vol. 8, Springer-Verlag Berlin Heidelberg, ISBN 978-3-540-56670-0, doi:10.1007/978-3-540-78862-1 (1993).\n\n\n\n\n\n","category":"function"},{"location":"#Green-Functions","page":"Overview","title":"Green Functions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"GreenFunction","category":"page"},{"location":"#KadanoffBaym.GreenFunction","page":"Overview","title":"KadanoffBaym.GreenFunction","text":"GreenFunction(g::AbstractArray, s::AbstractSymmetry)\n\nA container interface for g with array indexing respecting some symmetry rule s. Because of that, g must be square in its last 2 dimensions, which can be resized  with resize!.\n\nThe array g is not restricted to being contiguous. For example, g can have Matrix{T}, Array{T,4}, Matrix{SparseMatrixCSC{T}}, etc as its type.\n\nNotes\n\nThe GreenFunction does not own g. Proper care must be taken when using multiple GreenFunctions since using the same array will result in unexpected behaviour\n\njulia> data = zeros(2,2)\njulia> g1 = GreenFunction(data, Symmetrical)\njulia> g2 = GreenFunction(data, Symmetrical)\njulia> g1[1,1] = 3\njulia> @show g2[1,1]\njulia> g1.data === g2.data # they share the same data\n\nIndexing with less indices than the dimension of g results in a  \"take-all-to-the-left\" indexing\n\njulia> gf[i,j] == gf[:,:,...,:,i,j]\njulia> gf[i,j,k] == gf[:,:,...,:,i,j,k]\n\nCustom symmetries can be implemented via multiple dispatch\n\njulia> struct MySymmetry <: KadanoffBaym.AbstractSymmetry end\njulia> @inline KadanoffBaym.symmetry(::Type{MySymmetry}) = conj\n\nExamples\n\nGreenFunction simply takes some data g and embeds the symmetry s in its indexing\n\njulia> time_dim = 3\njulia> spin_dim = 2\njulia> data = zeros(spin_dim, spin_dim, time_dim, time_dim)\njulia> gf = GreenFunction(data, Symmetrical)\njulia> gf[2,1] = rand(spin_dim, spin_dim)\njulia> @show gf[1,2]\njulia> @show KadanoffBaym.symmetry(Symmetrical)(gf[2,1])\n\n\n\n\n\n","category":"type"},{"location":"#Wigner-Transformation","page":"Overview","title":"Wigner Transformation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"wigner_transform","category":"page"},{"location":"#KadanoffBaym.wigner_transform","page":"Overview","title":"KadanoffBaym.wigner_transform","text":"wigner_transform(x::AbstractMatrix; ts=1:size(x,1), fourier=true)\n\nWigner-Ville transformation\n\nx_W(ω T) = i dt x(T + t2 T - t2) e^+i ω t\n\nor\n\nx_W(τ T) = x(T + t2 T - t2)\n\nof a 2-point function x. Returns a tuple of x_W and the corresponding axes (ω, T) or (τ, T), depending on the fourier keyword.\n\nThe motivation for the Wigner transformation is that, given an autocorrelation function x, it reduces to the spectral density function at all times T for  stationary processes, yet it is fully equivalent to the non-stationary  autocorrelation function. Therefore, the Wigner (distribution) function tells  us, roughly, how the spectral density changes in time.\n\nOptional keyword parameters\n\nts::AbstractVector: Time grid for x. Defaults to a UnitRange.\nfourier::Bool: Whether to Fourier transform. Defaults to true.\n\nNotes\n\nThe algorithm only works when ts – and consequently x – is equidistant.\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Wigner_distribution_function\n\nhttp://tftb.nongnu.org\n\n\n\n\n\n","category":"function"},{"location":"#Langreth's-rules","page":"Overview","title":"Langreth's rules","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"TimeOrderedGreenFunction","category":"page"},{"location":"#KadanoffBaym.TimeOrderedGreenFunction","page":"Overview","title":"KadanoffBaym.TimeOrderedGreenFunction","text":"TimeOrderedGreenFunction(L::AbstractMatrix, G::AbstractMatrix)\n\nA simple time-ordered Green function structure for a hassle-free computation of the Langreth rules.\n\nParameters\n\nL::AbstractMatrix: The lesser component\nG::AbstractMatrix: The greater component\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"conv","category":"page"},{"location":"#KadanoffBaym.conv","page":"Overview","title":"KadanoffBaym.conv","text":"conv(L::AbstractTimeOrderedGreenFunction, R::AbstractTimeOrderedGreenFunction, ws::UpperTriangular)\n\nCalculates a time-convolution between time-ordered Green functions through the Langreth rules.\n\nParameters\n\nL::AbstractTimeOrderedGreenFunction: The left time-ordered Green function\nR::AbstractTimeOrderedGreenFunction: The right time-ordered Green function\nws::UpperTriangular: An upper-triangular weight matrix containing the integration weights\n\n\n\n\n\n","category":"function"},{"location":"#Citation","page":"Overview","title":"Citation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"If you use KadanoffBaym.jl in your research, please cite our paper:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@Article{10.21468/SciPostPhysCore.5.2.030,\n\ttitle={{Adaptive Numerical Solution of Kadanoff-Baym Equations}},\n\tauthor={Francisco Meirinhos and Michael Kajan and Johann Kroha and Tim Bode},\n\tjournal={SciPost Phys. Core},\n\tvolume={5},\n\tissue={2},\n\tpages={30},\n\tyear={2022},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCore.5.2.030},\n\turl={https://scipost.org/10.21468/SciPostPhysCore.5.2.030},\n}","category":"page"},{"location":"examples/FermiHubbardTM/#FHM_II","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"","category":"section"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"note: Note\nThis example is the continuation of Fermi-Hubbard Model I. It is recommended that you familiarize yourself with the latter first.","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"In part II of our example about the Fermi-Hubbard model, we will solve the so-called T-matrix approximation, which is a \"non-perturbative\" self-energy resummation. As we saw in part I, in the standard perturbative second Born approximation, the self-energies are given by","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"beginalign*\n    Sigma^lessgtr_ij uparrow  (t t) = mathrmiU^2 Phi^lessgtr_ij(t t) G^gtrless_ji downarrow(t t)\n    Sigma^lessgtr_ij downarrow(t t) = mathrmiU^2 Phi^lessgtr_ij(t t)G^gtrless_ji uparrow(t t)\nendalign*","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"where","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"beginalign*\n    leftboldsymbolPhi^lessgtr(t t)right_ij = Phi^lessgtr_ij(t t) = -i G^lessgtr_ij uparrow(t t) G^lessgtr_ij downarrow(t t)\n    endalign*","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"If we now define the so-called T-matrix","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"beginalign*\n    boldsymbolT(t t) =  boldsymbolPhi(t t) - U int_mathcalCmathrmds boldsymbolPhi(t s) boldsymbolT(s t)\nendalign*","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"the new self-energies in T-matrix approximation become","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"beginalign*\n    Sigma^lessgtr_ij uparrow  (t t) = mathrmiU^2 T^lessgtr_ij(t t) G^gtrless_ji downarrow(t t)\n    Sigma^lessgtr_ij downarrow(t t) = mathrmiU^2 T^lessgtr_ij(t t)G^gtrless_ji uparrow(t t)\nendalign*","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"While we keep the same initial conditions as in Fermi-Hubbard Model I, we intrdoce a new data struct that also holds the T-matrix (and the \"bubbles\" Phi since this is more efficient):","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"Base.@kwdef struct FermiHubbardDataTM{T}\n    GL_u::T\n    GG_u::T\n    GL_d::T\n    GG_d::T\n\n    ΣL_u::T = zero(GL_u)\n    ΣG_u::T = zero(GG_u)\n    ΣL_d::T = zero(GL_d)\n    ΣG_d::T = zero(GG_d)\n\n    TL::T = zero(GL_u)\n    TG::T = zero(GG_u)\n\n    ΦL::T = zero(GL_u)\n    ΦG::T = zero(GG_u)\nend\n\ndata = FermiHubbardDataTM(GL_u=GL_u, GG_u=GG_u, GL_d=GL_d, GG_d=GG_d)\n\n# Initialize T-matrix\ndata.TL[1, 1] = -1.0im .* GL_u[1, 1] .* GL_d[1, 1]\ndata.TG[1, 1] = -1.0im .* GG_u[1, 1] .* GG_d[1, 1]\ndata.ΦL[1, 1] = data.TL[1, 1]\ndata.ΦG[1, 1] = data.TG[1, 1]","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"note: Note\nAs should be clear from the new definition of the self-energies in terms of the T-matrix, the former now contain additional time integrals. This means that at every time step, on top of the Volterra integro-differential equations (VIDEs), we now also have to solve so-called Volterra integral equations (VIEs). Furthermore, it is important for stability reasons to solve these VIEs implicitly. For a more detailed discussion, please consult our paper.","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"Accordingly, we introduce an auxiliary fixed-point solver that does this for us:","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"function fixed_point(F::Function, x0::AbstractArray; \n        mixing::Float64=0.5, \n        abstol::Float64=1e-12, \n        maxiter::Int=1000, \n        verbose::Bool=true, \n        norm=x -> LinearAlgebra.norm(x, Inf)\n    )\n    \n    x_old = copy(x0)\n\n    step = 0\n    while step < maxiter\n        x = F(x_old)\n        res = norm(x - x_old)\n        if verbose\n            @info \"step: $step // res: $res\"\n        end\n        if res < abstol\n            break\n        end\n        @. x_old = mixing * x + (1.0 - mixing) * x_old\n        step += 1\n    end\n\n    if step == maxiter\n        @warn \"No convergence reached.\"\n    end\n\n    return x_old\nend","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"Instead of writing one ourselves, we could also have worked directly with NLsolve.jl. Note that to keep our number of dependencies low, we have opted for not including this by default.","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"As in part I, we define our FermiHubbardModel, yet this time with a stronger interaction:","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"# Interaction parameter\nconst U₀ = 2.0\nmodel = FermiHubbardModel(U = t -> U₀)","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"The previous callback second_Born! is now replaced with the following:","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"# Callback function for the self-energies\nfunction T_matrix!(model, data, times, h1, h2, t, t′)\n    # Unpack data and model\n    (; GL_u, GG_u, GL_d, GG_d, TL, TG, ΣL_u, ΣG_u, ΣL_d, ΣG_d, ΦL, ΦG) = data\n    (; U) = model\n        \n    # Real-time collision integral\n    ∫dt1(A, B, C) = integrate1(h1, t, t′, A, B, C)\n    ∫dt2(A, B, C) = integrate2(h2, t, t′, A, B, C)\n    \n    # Resize self-energies etc. when Green functions are resized\n    if (n = size(GL_u, 3)) > size(ΣL_u, 3)\n        resize!(ΣL_u, n)\n        resize!(ΣG_u, n)\n        resize!(ΣL_d, n)\n        resize!(ΣG_d, n)\n        \n        resize!(TL, n)\n        resize!(TG, n)\n        resize!(ΦL, n)\n        resize!(ΦG, n)\n    end\n    \n    # The interaction varies as a function of the forward time (t+t')/2\n    U_t = U((times[t] + times[t′])/2)\n    \n    # Set all Φs at the very first t′ since they are all known by then\n    if t′ == 1\n        for t′ in 1:t\n            ΦL[t, t′] = -1.0im .* GL_u[t, t′] .* GL_d[t, t′]\n            ΦG[t, t′] = -1.0im .* GG_u[t, t′] .* GG_d[t, t′]\n        end\n    end   \n\n    # Solve VIEs implicitly\n    TL[t, t′], TG[t, t′] = fixed_point([ΦL[t, t′], ΦG[t, t′]]; mixing=0.5, verbose=false) do x\n        TL[t, t′], TG[t, t′] = x[1], x[2]\n        \n        [\n            ΦL[t, t′] - U_t * (∫dt1(ΦG, ΦL, TL) + ∫dt2(ΦL, TL, TG)),\n            ΦG[t, t′] - U_t * (∫dt1(ΦG, ΦL, TG) + ∫dt2(ΦG, TL, TG))\n        ]\n    end\n    \n    # Define the self-energies\n    ΣL_u[t, t′] = 1.0im .* U_t^2 .* TL[t, t′] .* transpose(GG_d[t′, t])\n    ΣL_d[t, t′] = 1.0im .* U_t^2 .* TL[t, t′] .* transpose(GG_u[t′, t])\n    \n    ΣG_u[t, t′] = 1.0im .* U_t^2 .* TG[t, t′] .* transpose(GL_d[t′, t])\n    ΣG_d[t, t′] = 1.0im .* U_t^2 .* TG[t, t′] .* transpose(GL_u[t′, t])\nend","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"For a given final time tmax, and tolerances atol and rtol, kbsolve! is ready to solve the problem:","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"# Call the solver\nsol = kbsolve!(\n        (x...) -> fv!(model, data, x...),\n        (x...) -> fd!(model, data, x...),\n        [data.GL_u, data.GG_u, data.GL_d, data.GG_d],\n        (0.0, tmax);\n        callback = (x...) -> T_matrix!(model, data, x...),\n        atol = atol,\n        rtol = rtol,\n        dtini=1e-10,\n        stop = x -> (println(\"t: $(x[end])\"); flush(stdout); false)\n    )","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"At large tmax=32 and with atol = 1e-2 rtol, we obtain","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"(Image: Comparison of T-matrix and second Born approximations for different tolerances)","category":"page"},{"location":"examples/FermiHubbardTM/","page":"Fermi-Hubbard Model II","title":"Fermi-Hubbard Model II","text":"This confirms that the resummation performed by the T-matrix is indeed superior to the second Born approximation in the current regime of large U and small occupation numbers!","category":"page"}]
}
